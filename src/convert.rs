use csv;

use std::io::{File};

pub fn convert_dispatch_latency(filename: &str) {
    let mut rdr = csv::Decoder::from_file(&Path::new(filename))
                                .separator(b';')
                                .enforce_same_length(false);

    // Ignore comment lines generated by benchmark tool
    for i in range(0u,3) {
      rdr.iter().next();
    }
    // Fetch and rearrange data
    let mut data: Vec<(int, int, int)> = Vec::with_capacity(16384 * 2);
    for row in rdr.iter_decode::<(int, int, int)>() {
        let (x1, x2, x3) = row.unwrap();
        data.push((x1, x2 - x1, x3));
    }

    //
    // Save data
    //
    let dest_filename = "dispatch_".to_string() + String::from_str(filename);
    let mut file = File::create(&Path::new(dest_filename.as_slice()));
    // Add header
    file.write(b"requestLatency;startLatency;ExecutionTime\n")
        .ok().expect("Unable to write header line.");
    // Write data
    let mut enc = csv::Encoder::to_writer(file)
                                .separator(b';');
    match enc.encode_all(data.iter()) {
        Ok(_) => {},
        Err(err) => fail!("Error saving csv file: {}", err),
    }
}
