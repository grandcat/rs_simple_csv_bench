extern crate csv;

use std::io::{File};
use std::num::{abs};
use std::os;

static CACHE_SIZE: uint = 16384;

fn main() {
    // Extract input file
    let args: Vec<String> = os::args();
    if args.len() != 2 {
      fail!("No input file provided. Please pass one as argument!");
    }

    // Open CSV file with statistics
    let file = File::open(&Path::new(args[1].as_slice()));
    let mut rdr = csv::Decoder::from_reader(file);
    rdr.separator(';');
    rdr.has_headers(true);
    rdr.enforce_same_length(false);
    // Ignore comment lines generated by benchmark suite
    for i in range(0u,3) {
      let ignored = rdr.iter().next();
      // println!("{} length", ignored.unwrap().len());
    }

    // Vectors for storage of data items
    let mut data : Vec<Vec<int>> = Vec::with_capacity(3);
    data.push(Vec::with_capacity(CACHE_SIZE)); // event latency
    data.push(Vec::with_capacity(CACHE_SIZE)); // dispatch latency + event latency
    data.push(Vec::with_capacity(CACHE_SIZE)); // execution time

    for (event_latency, dispatch_latency, exec_time) in rdr.decode_iter::<(int, int, int)>() {
        // println!("{}, {}, {}", event_latency, dispatch_latency, exec_time);
        data.get_mut(0).push(event_latency);
        data.get_mut(1).push(dispatch_latency);
        data.get_mut(2).push(exec_time);
    }

    // Sort vectors
    data.get_mut(0).sort_by(|a, b| compare_ints(a, b)); // |a, b| a.cmp(b)
    data.get_mut(1).sort_by(|a, b| compare_ints(a, b));
    data.get_mut(2).sort_by(|a, b| compare_ints(a, b));

    // for item in data[0].iter() {
    //     println!("{}", item);
    // }
    for dataset_id in range(0u, 3) {
        let dataset = &data[dataset_id];
        println!("Dataset {} with {} entries:", dataset_id, dataset.len());
        // Statistics about current dataset
        let (quantile_min, quantile_max) = get_quantiles(dataset);
        println!("First & Last & 5% & 95% & average & stdDev & avgMedianDev & medianDev")
        println!("{} & {} & {} & {} & {} & {} & {} & {}",
                 get_first(dataset), get_last(dataset),
                 quantile_min, quantile_max,
                 get_avg(dataset), get_variance(dataset).sqrt(),
                 get_average_abs_deviation(dataset),
                 get_median_abs_deviation(dataset));

        println!("-----------------------------")
    }
}

fn get_first(input: &Vec<int>) -> int {
    input[0]
}

fn get_last(input: &Vec<int>) -> int {
    input[input.len() - 1]
}

fn get_avg(input: &Vec<int>) -> f32 {
    let mut sum = 0f32;

    for item in input.iter() {
        sum += *item as f32;
    }
    // Result
    return sum / (input.len() as f32);
}

fn get_median(input: &Vec<int>) -> int {
    let midway = input.len() / 2;
    // Result
    input[midway]
}

fn get_variance(input: &Vec<int>) -> f32 {
    let avg: f32 = get_avg(input);
    let mut variance = 0f32;

    for item in input.iter() {
        let diff = (*item as f32) - avg;
        variance += diff * diff;
    }

    variance /= (input.len() - 1) as f32;
    // Result
    variance
}

/// Average absolute deviation about median
///
/// Implement http://en.wikipedia.org/wiki/Median_absolute_deviation instead
fn get_average_abs_deviation(input: &Vec<int>) -> f32 {
    let median = get_median(input);

    let mut sum = 0i;
    for item in input.iter() {
        let diff = abs(item - median);
        sum += diff;
    }
    let res = (sum as f32) / (input.len() as f32);
    // Result
    res
}

/// Median absolute deviation (MAD)
fn get_median_abs_deviation(input: &Vec<int>) -> int {
    let median = get_median(input);

    let mut abs_deviations: Vec<int> = Vec::with_capacity(input.len());
    for item in input.iter().map(|&x| abs(x - median)) {
        abs_deviations.push(item);
    }
    // Sort new deviations to calculate the median
    abs_deviations.sort_by(|a, b| compare_ints(a, b));
    // Return median
    get_median(&abs_deviations)
}

/// Calculate 5% and 95% quantiles
fn get_quantiles(input : &Vec<int>) -> (int, int) {
    let low_index = ((input.len()-1) * 5u) / 100u;
    let high_index = ((input.len()-1) * 95u) / 100u;
    // Result
    (input[low_index], input[high_index])
}

fn compare_ints(left : &int, right : &int) -> Ordering {
    if left < right {
      Less
    } else if left > right {
      Greater
    } else {
      Equal
    }
}
